#![allow(clippy::multiple_crate_versions)]

use cargo_metadata::MetadataCommand;
use chrono::Utc;
use git2::{BranchType, Branches, Repository, StatusOptions};
use inquire::{Confirm, MultiSelect, Select, Text};
use std::env::consts::OS;
use std::fs::{self, read_to_string, remove_file, File};
use std::io::Write;
use std::path::Path;
use std::path::MAIN_SEPARATOR_STR;
use std::process::{Command, ExitCode};

const DEFAULT_PATH: &str = ".";
const COMMIT_TEMPLATE: &str = "%type% (%scope%): %summary%\n\nThe following changes were made :\n\n%why%\n\nAuthored by : %author% <%mail%>";

const INIT: &str = "Init flow";
const COMMIT: &str = "Write a commit message";
const STASH: &str = "Stash modification";
const BLAME: &str = "Show blame";
const SEND_TO_REMOTE: &str = "Send to remote";
const PULL: &str = "Get modifications from the remote";
const LIST_PULL_REQUESTS: &str = "List of your pull request";
const RENAME_REPOSITORY: &str = "Rename the repository";
const CREATE_PULL_REQUEST: &str = "Create a pull request";
const UPDATE_PULL_REQUEST_BRANCH: &str = "Update a pull request branch";
const LOGIN: &str = "Login to Github";
const LOGOUT: &str = "Logout to Github";
const REFRESH_CREDENTIALS: &str = "Refresh crendentials";
const BROWSE: &str = "Open repository on default browser";
const SHOW_BRANCHES: &str = "Show branches";
const CLONE_GIST: &str = "Clone a gist";
const CLONE_REPO: &str = "Clone a repository";
const CREATE_GIST: &str = "Create a gist";
const DELETE_GIST: &str = "Delete a gist";
const EDIT_GIST: &str = "Edit a gist";
const LIST_GIST: &str = "List your gists";
const VIEW_GIST: &str = "View a gists";
const REMOVE_GIST: &str = "Remove a gist";
const RENAME_GIST: &str = "Rename a file in a gist";
const RELEASE_CREATE: &str = "Create a new release";
const RELEASE_DELETE: &str = "Delete a release";
const RELEASE_DOWNLOAD: &str = "Download a release";
const RELEASE_EDIT: &str = "Edit a release";
const RELEASE_LIST: &str = "List releases";
const RELEASE_UPLOAD: &str = "Upload assets to a releases";
const RELEASE_VIEW: &str = "View information about a release";
const RELEASE_DELETE_ASSETS: &str = "Delete an asset from a release";
const CREATE_ISSUES: &str = "Create a issue";
const DELETE_ISSUES: &str = "Delete a gist";
const EDIT_ISSUES: &str = "Edit issues";
const LIST_ISSUES: &str = "List issues";
const PIN_ISSUES: &str = "Pin an issues";
const UN_PIN_ISSUES: &str = "Unpin an issue";
const REOPEN_ISSUES: &str = "Reopen issue";
const STATUS_ISSUES: &str = "Show status of a relevant issues";
const TRANSFER_ISSUE: &str = "Transfer issue to another repository";
const VIEW_ISSUES: &str = "View an issue";
const CLOSE_ISSUE: &str = "Close a issue";
const LOCK_ISSUE: &str = "Lock issue conversation";
const UNLOCK_ISSUE: &str = "Unlock issue conversation";
const COMMENT_ISSUE: &str = "Add a comment to an issue";
const GPG_KEY: &str = "Manage gpg key";
const REMOVE_BRANCHES: &str = "Remove branches";
const SHOW_STATS: &str = "Show stats";
const SHOW_DIFF: &str = "Show diff";
const SHOW_LOGS: &str = "Show logs";
const CANCEL_WORKFLOW: &str = "Cancel a workflow";
const REMOVE_WORKFLOW: &str = "Remove a workflow";
const DOWNLOAD_WORKFLOW: &str = "Download artifacts generated by a workflow run";
const LIST_WORKFLOW: &str = "List recent workflows run";
const WATCH_WORKFLOW: &str = "Watch a run until it completes, showing its progress";
const VIEW_WORKFLOW: &str = "View a summary of a workflow run";
const RERUN_WORKFLOW: &str = "Rerun a run";
const DELETE_WORKFLOW_CACHE: &str = "Delete GitHub Actions caches";
const LIST_WORKFLOW_CACHE: &str = "List GitHub Actions caches";
const GENERATE_CHANGE_LOG: &str = "Generate the changes log";
const SHOW_STATUS: &str = "Display workflow status";
const START_FEATURE: &str = "Start a new feature";
const REMOVE_FEATURE: &str = "Remove a feature";
const FINISH_FEATURE: &str = "Finnish a feature";
const START_HOTFIX: &str = "Start a new hotfix";
const REMOVE_HOTFIX: &str = "Remove a hotfix";
const FINISH_HOTFIX: &str = "Finnish a hotfix";
const START_REALEASE: &str = "Start a new release";
const REMOVE_RELEASE: &str = "Remove a release";
const FINISH_RELEASE: &str = "Finnish a release";

const OPTIONS: [&str; 69] = [
    INIT,
    COMMIT,
    STASH,
    BLAME,
    SEND_TO_REMOTE,
    PULL,
    LIST_PULL_REQUESTS,
    UPDATE_PULL_REQUEST_BRANCH,
    CREATE_PULL_REQUEST,
    LOGIN,
    LOGOUT,
    REFRESH_CREDENTIALS,
    BROWSE,
    SHOW_BRANCHES,
    CLONE_GIST,
    CLONE_REPO,
    CREATE_GIST,
    DELETE_GIST,
    LIST_GIST,
    VIEW_GIST,
    RENAME_GIST,
    RELEASE_CREATE,
    RELEASE_DELETE,
    RELEASE_DELETE_ASSETS,
    RELEASE_EDIT,
    RELEASE_LIST,
    RELEASE_DOWNLOAD,
    RELEASE_UPLOAD,
    RELEASE_VIEW,
    PIN_ISSUES,
    LOCK_ISSUE,
    LOCK_ISSUE,
    CLOSE_ISSUE,
    UN_PIN_ISSUES,
    EDIT_ISSUES,
    REOPEN_ISSUES,
    LIST_ISSUES,
    REOPEN_ISSUES,
    STATUS_ISSUES,
    COMMENT_ISSUE,
    TRANSFER_ISSUE,
    RENAME_REPOSITORY,
    RENAME_GIST,
    GPG_KEY,
    REMOVE_BRANCHES,
    SHOW_BRANCHES,
    UPDATE_PULL_REQUEST_BRANCH,
    SHOW_LOGS,
    SHOW_DIFF,
    SHOW_STATS,
    SHOW_STATUS,
    LIST_WORKFLOW,
    CANCEL_WORKFLOW,
    WATCH_WORKFLOW,
    RERUN_WORKFLOW,
    VIEW_WORKFLOW,
    DELETE_WORKFLOW_CACHE,
    REMOVE_WORKFLOW,
    DOWNLOAD_WORKFLOW,
    LIST_WORKFLOW_CACHE,
    REMOVE_FEATURE,
    START_FEATURE,
    FINISH_FEATURE,
    REMOVE_HOTFIX,
    START_HOTFIX,
    FINISH_HOTFIX,
    START_REALEASE,
    FINISH_RELEASE,
    REMOVE_RELEASE,
];
const DEV_BRANCH: &str = "develop";
const FEATURE_BRANCH_PREFIX: &str = "feature";

const LANG: &str = "en_US";
const HELP: [&str; 68] = [
    "Star: New feature or enhancement",
    "Comet: Bug fix or error resolution",
    "Nebula: Code refactoring",
    "Pulsar: Performance improvement",
    "Quasar: Documentation or clarity improvement",
    "Asteroid Belt: Code cleanup and maintenance",
    "Solar Flare: Testing-related changes",
    "Dwarf Planet: Minor updates or fixes",
    "Terraform: Infrastructure changes",
    "Black Hole: Removing large chunks of code or features",
    "Wormhole: Merging branches or connecting code parts",
    "Big Bang: Initial commit or major feature start",
    "Launch: Deploying to production or releasing a version",
    "Lightspeed: Significant performance improvements",
    "Mission Control: Project management changes",
    "Spacewalk: Urgent hotfixes",
    "Moon Landing: Major milestone or goal completion",
    "First Contact: Initial integrations with external systems",
    "Interstellar Communication: Improving documentation or communication",
    "Solar Eclipse: Temporarily masking functionality",
    "Supernova: Major, transformative change",
    "Meteor Shower: Series of small changes or fixes",
    "Solar Wind: Refactoring code structure",
    "Lunar Eclipse: Temporarily disabling a feature",
    "Cosmic Dawn: Initial implementation of a feature",
    "Solar Storm: Rapid, impactful changes",
    "Lunar Transit: Minor, temporary change",
    "Perihelion: Brings the project closer to its goals or objectives",
    "Aphelion: Immediate goals, but is necessary for long-term progress",
    "White Dwarf: Improving code comments or documentation",
    "Red Giant: Expanding a feature or functionality",
    "Neutron Star: Optimizing code for performance",
    "Binary Star: Merging features or components",
    "Brown Dwarf: Undeveloped feature with potential",
    "Quark Star: Experimental or speculative change",
    "Rogue Planet: Independent change",
    "Stellar Nursery: Creation of new components",
    "Planetary Nebula: Removal or deprecation of a component",
    "Globular Cluster: Collection of related changes",
    "Void: Removal of a module, component, or feature",
    "Gravity: Resolving merge conflicts or dependencies",
    "Dark Matter: Fixing unknown or mysterious bugs",
    "Time Dilation: Improving code performance",
    "Spacetime: Changes to date, time, or scheduling",
    "Gravitational Lensing: Altering data or information flow",
    "Cosmic String: Connecting code parts",
    "Quantum Fluctuation: Small, random change",
    "Hawking Radiation: Removing technical debt",
    "Quantum Entanglement: Establishing close relationships between code parts",
    "Gravitational Redshift: Slowing down or reducing code performance",
    "Space Probe: Testing new features or technologies",
    "Station: Creating or improving environments",
    "Rocket Launch: Deploying to production",
    "Spacewalk: Urgent production hotfixes",
    "Space Elevator: Making codebase more accessible",
    "Warp Drive: Significant speed improvement",
    "Dyson Sphere: Comprehensive optimization of a specific area",
    "Generation Ship: Long-term project for a self -sustaining system",
    "Lagrange Point: Stabilizing or balancing code parts",
    "Orbital Maneuver: Changing project direction",
    "Mission Control: Represents project management-related changes",
    "Moon Landing: Celebrates the completion of major milestones",
    "Interstellar Travel: Migration to a new architecture or language",
    "Rover: Exploration of new technologies or approaches",
    "Singularity: Resolution of a complex or hard-to-reproduce issue",
    "Relativity: Changes related to time, dates, or timestamps",
    "Expansion: Scaling up the system or increasing capacity",
    "Big Crunch: Reduction of codebase size or removal of features",
];

#[derive(Hash, PartialEq, Eq, PartialOrd, Ord)]
enum Flow {
    Init,
    StartFeature,
    FinnishFeature,
    RemoveFeature,
    Commit,
    ShowLog,
    ShowBranches,
    RemoveBranches,
    Diff,
    Pull,
    Push,
    Stash,
    Stats,
    ChangeLogGeneration,
    Blame,
}

fn check(sentence: &str) -> bool {
    let mut f = File::create("/tmp/commiter").expect("msg");
    writeln!(f, "{sentence}").expect("msg");
    let o = Command::new("hunspell")
        .arg("-d")
        .arg(LANG)
        .arg("-l")
        .arg("/tmp/commiter")
        .output()
        .expect("msg")
        .stdout;
    o.is_empty()
}
fn get_last_tag() -> String {
    let tag: String = String::from_utf8(
        Command::new("git")
            .arg("describe")
            .arg("--tags")
            .arg("--abbrev=0")
            .current_dir(".")
            .output()
            .unwrap()
            .stdout,
    )
    .expect("Faile to find a TAG");
    let data: Vec<&str> = tag.split('\n').collect();
    (*data.first().expect("msg")).to_string()
}
fn get_log() -> String {
    let log = File::create("log").expect("failed to create log");
    let d = format!("{}..HEAD", get_last_tag());
    assert!(Command::new("git")
        .arg("log")
        .arg("--format=fuller")
        .arg(d.as_str())
        .stdout(log)
        .current_dir(".")
        .spawn()
        .unwrap()
        .wait()
        .unwrap()
        .success());
    read_to_string("log").expect("failed to parse file")
}

fn program_or_lib() -> String {
    if read_to_string("Cargo.toml")
        .expect("no cargo project")
        .contains("lib")
    {
        String::from("library")
    } else {
        String::from("software")
    }
}
fn create_changelog() -> bool {
    if Path::new("./logs").is_dir().eq(&false) {
        fs::create_dir_all("./logs").expect("msg");
    }
    let filename = format!(
        "./logs{MAIN_SEPARATOR_STR}{}-{}-changes.md",
        project(),
        version()
    );
    let logs = get_log();
    let lines = logs.lines();
    let mut f = File::create(filename.as_str()).expect("failed to create file");
    writeln!(
        f,
        "# 🚀 {} {} released\n\nToday the `{}`, we are very happy to present the **{}** version of our `{}` {} !\n\nThis release marks a significant step forward for our {} {}.\n\n## Demonstration\n\n{}\n\n## What it's?\n\nIt's {}\n\n## What we do ?\n\n- {}\n\n## Our team\n\n- {}\n\n## Links\n\n- [Source code]({})\n- [Home]({})\n- [Issues]({})\n- [Pull Request]({})\n- [Discussions]({})\n- [Wiki]({})\n- [Projects]({})\n- [Releases]({})\n- [Crates.io](https://crates.io/crates/{}/{})\n",
        project(),
        version(),
        Utc::now().date_naive(),
        version(),
        project(),
        program_or_lib(),
        program_or_lib(),
        project(),
        project(),
        description(),
        keywords().join("\n- "),
        authors().join("\n- "),
        repository(),
        homepage(),
        issues(),
        pulls_request(),
        discussions(),
        wiki(),
        projects(),
        releases(),
        project(),
        version()
    )
    .expect("msg");
    for t in commit_types_with_help() {
        let ttt: Vec<&str> = t.split(':').collect();
        let title: String = (*ttt.last().unwrap()).to_string();
        writeln!(f, "###{title}\n").expect("msg");
        for line in lines.clone() {
            let current = (*ttt.first().unwrap()).to_string();
            if line.contains(current.as_str()) {
                let lll = line.split('\n');
                for l in lll {
                    let c = l.replace(ttt.first().unwrap(), "");
                    let cc: Vec<&str> = c.split(':').collect();
                    let ccc: Vec<&str> = cc.last().unwrap().split('\n').collect();
                    let message = ccc.join("\n");
                    writeln!(f, "\n  -{message}").expect("msg");
                }
            }
        }
    }
    writeln!(
        f,
        "\n## README\n\n{}\n\n## LICENSE\n\n```\n{}\n```",
        read_to_string(readme())
            .expect("readme file not founded")
            .trim(),
        read_to_string(license())
            .expect("LICENSE file not founded")
            .trim()
    )
    .expect("msg");
    remove_file("log").expect("failed to remove log");
    Path::new(filename.as_str()).exists()
}
fn issues() -> String {
    let mut x = repository();
    if x.contains("github") {
        x.push_str("/issues");
    } else if x.contains("gitlab") {
        x.push_str("-/issues");
    }
    x
}

fn wiki() -> String {
    let mut x = repository();
    if x.contains("github") {
        x.push_str("/wiki");
    } else if x.contains("gitlab") {
        x.push_str("-/wikis");
    }
    x
}
fn projects() -> String {
    let mut x = repository();
    if x.contains("github") {
        x.push_str("/projects");
    }
    x
}

fn pulls_request() -> String {
    let mut x = repository();
    if x.contains("github") {
        x.push_str("/pulls");
    } else if x.contains("gitlab") {
        x.push_str("-/merge_requests");
    }
    x
}

fn discussions() -> String {
    let mut x = repository();
    if x.contains("github") {
        x.push_str("/discussions");
    }
    x
}

fn create_patch() {
    if Path::new("./patches").exists().eq(&false) {
        assert!(fs::create_dir_all("./patches").is_ok());
    }
    assert!(Command::new("git")
        .arg("format-patch")
        .arg("-1")
        .current_dir("./patches")
        .spawn()
        .unwrap()
        .wait()
        .unwrap()
        .success());
}
fn create_tag() {
    let m: String = Text::new("Enter the tag message : ").prompt().unwrap();

    let v: String = Text::new("Enter the tag version : ")
        .with_default(version().as_str())
        .prompt()
        .unwrap();

    if m.is_empty() || v.is_empty() {
        create_tag();
    }
    assert!(Command::new("git")
        .arg("tag")
        .arg("-a")
        .arg(v.as_str())
        .arg("-m")
        .arg(m.as_str())
        .current_dir(".")
        .spawn()
        .unwrap()
        .wait()
        .unwrap()
        .success());
    assert!(Command::new("cargo")
        .arg("publish")
        .current_dir(".")
        .spawn()
        .unwrap()
        .wait()
        .unwrap()
        .success());
}

fn send_tag() {
    assert!(Command::new("git")
        .arg("push")
        .arg("--all")
        .current_dir(".")
        .spawn()
        .unwrap()
        .wait()
        .unwrap()
        .success());
    assert!(Command::new("git")
        .arg("push")
        .arg("--tags")
        .current_dir(".")
        .spawn()
        .unwrap()
        .wait()
        .unwrap()
        .success());
}
fn commit(m: &str) -> bool {
    assert!(Command::new("git")
        .arg("commit")
        .arg("-m")
        .arg(m)
        .current_dir(".")
        .spawn()
        .unwrap()
        .wait()
        .unwrap()
        .success());
    create_patch();
    if confirm("Create new tag", false) {
        create_tag();
        send_tag();
    }
    true
}

fn diff() -> bool {
    Command::new("git")
        .arg("diff")
        .current_dir(".")
        .spawn()
        .expect("git")
        .wait()
        .unwrap()
        .success()
}

fn fmt() {
    assert!(Command::new("cargo")
        .arg("fmt")
        .current_dir(".")
        .spawn()
        .unwrap()
        .wait()
        .unwrap()
        .success());
    clear();
}

fn zuu() -> bool {
    clear();

    if Path::new("Cargo.toml").exists() {
        fmt();
        if Command::new("zuu")
            .current_dir(".")
            .spawn()
            .unwrap()
            .wait()
            .unwrap()
            .success()
        {
            clear();
            return true;
        }
        return false;
    }
    clear();
    true
}

fn version() -> String {
    let metadata = MetadataCommand::new().no_deps().exec().unwrap();
    let package = metadata.packages.first().unwrap();
    package.version.to_string()
}

fn dependencies() -> Vec<String> {
    let metadata = MetadataCommand::new().no_deps().exec().unwrap();
    let package: &cargo_metadata::Package = metadata.packages.first().unwrap();
    let dependency_names: Vec<String> = package
        .dependencies
        .iter()
        .map(|dep| dep.name.clone())
        .collect();
    dependency_names
}

fn releases() -> String {
    let mut x = repository();
    if x.contains("github") {
        x.push_str("/releases");
    } else if x.contains("gitlab") {
        x.push_str("-/tags");
    }
    x
}
fn project() -> String {
    let metadata = MetadataCommand::new().no_deps().exec().unwrap();
    let package: &cargo_metadata::Package = metadata.packages.first().unwrap();
    package.name.to_string()
}

fn keywords() -> Vec<String> {
    let metadata = MetadataCommand::new().no_deps().exec().unwrap();
    let package: &cargo_metadata::Package = metadata.packages.first().unwrap();
    package.keywords.clone()
}

fn homepage() -> String {
    let metadata = MetadataCommand::new().no_deps().exec().unwrap();
    let package: &cargo_metadata::Package = metadata.packages.first().unwrap();
    package.clone().homepage.expect("no homepage")
}

fn readme() -> String {
    let metadata = MetadataCommand::new().no_deps().exec().unwrap();
    let package: &cargo_metadata::Package = metadata.packages.first().unwrap();
    package
        .clone()
        .readme
        .expect("no readme define")
        .to_string()
}

fn license() -> String {
    let metadata = MetadataCommand::new().no_deps().exec().unwrap();
    let package: &cargo_metadata::Package = metadata.packages.first().unwrap();
    package
        .clone()
        .license_file
        .expect("no licences define")
        .to_string()
}

fn repository() -> String {
    let metadata = MetadataCommand::new().no_deps().exec().unwrap();
    let package: &cargo_metadata::Package = metadata.packages.first().unwrap();
    package.clone().repository.expect("no repository define")
}

///
/// # Panics
///
fn description() -> String {
    let metadata = MetadataCommand::new().no_deps().exec().unwrap();
    let package: &cargo_metadata::Package = metadata.packages.first().unwrap();
    package
        .description
        .as_ref()
        .expect("missing description")
        .to_string()
}

fn authors() -> Vec<String> {
    let metadata = MetadataCommand::new().no_deps().exec().unwrap();
    let package: &cargo_metadata::Package = metadata.packages.first().unwrap();
    package.authors.clone()
}
fn clear() {
    if OS.eq("windows") {
        assert!(Command::new("cls")
            .current_dir(".")
            .spawn()
            .unwrap()
            .wait()
            .unwrap()
            .success());
    } else {
        assert!(Command::new("clear")
            .current_dir(".")
            .spawn()
            .unwrap()
            .wait()
            .unwrap()
            .success());
    }
}

fn commit_types_with_help() -> [&'static str; 68] {
    let mut x = HELP;
    x.sort_unstable();
    x
}

fn commit_scope() -> String {
    let mut scope: String;
    loop {
        scope = Text::new("Please enter the commit scope : ")
            .prompt()
            .unwrap();
        if scope.is_empty() {
            continue;
        }
        if scope.len().gt(&20) {
            println!("scope can be superior to 20 character");
            continue;
        }
        if confirm(
            format!("Really use the commit scope : {scope}").as_str(),
            false,
        ) {
            break;
        }
    }
    scope
}

fn commit_types() -> String {
    let mut t: String;
    loop {
        t = Select::new(
            "Please enter the commit type : ",
            commit_types_with_help().to_vec(),
        )
        .prompt()
        .unwrap()
        .to_string();
        if t.is_empty() {
            continue;
        }
        if confirm(format!("Really use the commit type : {t}").as_str(), false) {
            break;
        }
    }
    let x: Vec<&str> = t.split(':').collect();
    (*x.first().unwrap()).to_string()
}

fn commit_summary() -> String {
    let mut summary: String;
    loop {
        summary = Text::new("Please enter the commit summary : ")
            .prompt()
            .unwrap();
        if summary.is_empty() {
            continue;
        }
        if summary.len().gt(&50) {
            println!("Summary must be contains less than 50 chararacter");
            continue;
        }
        if confirm(format!("Use the summary : {summary}").as_str(), false) {
            break;
        }
    }
    summary
}

fn commit_description() -> String {
    let mut description: String = String::new();
    loop {
        let d = Text::new("Please enter the commit description : ")
            .prompt()
            .unwrap();
        if d.is_empty() {
            continue;
        }
        description.push_str(format!("{d}\n\n").as_str());
        if confirm("Add a new description line", false) {
            continue;
        }
        break;
    }
    description
}

fn commit_why() -> String {
    let mut why: String = String::new();
    loop {
        let w = Text::new("Please explain the reasoning behind the change : ")
            .prompt()
            .unwrap();
        if w.is_empty() {
            continue;
        }
        if w.len().gt(&50) {
            println!("The reasoning behind the change must be contains less than 50 chararacter");
            continue;
        }
        why.push_str(format!("\n\t* {w}").as_str());
        if confirm("Continue to write the changes : ", false) {
            continue;
        }
        break;
    }
    why
}
fn commit_footer() -> String {
    let mut footer: String = String::new();
    if confirm("Code has breaking changes ?", false) {
        footer.push_str("BREAKING CHANGE: ");
        loop {
            let b = Text::new("Please enter the breaking change description: ")
                .prompt()
                .unwrap();
            if b.is_empty() {
                continue;
            }
            if confirm(
                format!("Use breaking change description : {b}").as_str(),
                false,
            ) {
                footer.push_str(b.as_str());
                break;
            }
        }
    }
    if confirm("Code has resolving issues ?", false) {
        loop {
            footer.push_str("\n\tFixes ");
            let f = Text::new("Please enter the issue number : ")
                .prompt()
                .unwrap();
            if f.is_empty() {
                continue;
            }
            footer.push_str(format!("#{f}\n").as_str());
            if confirm("Code resolving an other issues ?", false) {
                continue;
            }
            break;
        }
    }
    if confirm("Code resolve an issue ?", false) {
        loop {
            footer.push_str("\n\tCloses ");
            let f = Text::new("Please enter the issue number : ")
                .prompt()
                .unwrap();
            if f.is_empty() {
                continue;
            }
            footer.push_str(format!("#{f}\n").as_str());
            if confirm("Code resolve an other issue ?", false) {
                continue;
            }
            break;
        }
    }
    footer
}

fn bad_sentences() {
    println!("The entered text is not correct: it must be written in English and not contain any errors.");
}
fn get_scope() -> String {
    let mut scope: String;
    loop {
        scope = commit_scope();
        if check(scope.as_str()) {
            break;
        }
        bad_sentences();
    }
    scope
}

fn get_summary() -> String {
    let mut summary: String;
    loop {
        summary = commit_summary();
        if check(summary.as_str()) {
            break;
        }
        bad_sentences();
    }
    summary
}

fn get_description() -> String {
    let mut description: String;
    loop {
        description = commit_description();
        if check(description.as_str()) {
            break;
        }
        bad_sentences();
    }
    description
}

fn get_why() -> String {
    let mut why: String;
    loop {
        why = commit_why();
        if check(why.as_str()) {
            break;
        }
        bad_sentences();
    }
    why
}
fn get_footer() -> String {
    let mut footer: String;
    loop {
        footer = commit_footer();
        if check(footer.as_str()) {
            break;
        }
        bad_sentences();
    }
    footer
}
fn prepare_commit() -> bool {
    let c = format!(
        "{}({}): {}\n\n{}\n\nThe following changes were made:\n\t{}\n\nThe changes :\n{}\n\nCo-authored-by: {} <{}>",
        commit_types(),
        get_scope(),
        get_summary(),
        get_description(),
        get_why(),
        get_footer(),
        name(),
        email()
    );
    commit(c.as_str())
}

fn confirm(msg: &str, default: bool) -> bool {
    Confirm::new(msg)
        .with_default(default)
        .prompt()
        .unwrap()
        .eq(&true)
}

fn email() -> String {
    String::from_utf8(
        Command::new("git")
            .arg("config")
            .arg("--get")
            .arg("user.email")
            .current_dir(".")
            .output()
            .expect("git email not found")
            .stdout,
    )
    .expect("msg")
    .trim()
    .to_string()
}

fn name() -> String {
    String::from_utf8(
        Command::new("git")
            .arg("config")
            .arg("--get")
            .arg("user.name")
            .current_dir(".")
            .output()
            .expect("username not found")
            .stdout,
    )
    .expect("msg")
    .trim()
    .to_string()
}

enum Verb {
    Start,
    Finish,
}

fn checkout(b: &str) -> bool {
    Command::new("git")
        .arg("checkout")
        .arg(b)
        .current_dir(".")
        .spawn()
        .expect("git")
        .wait()
        .unwrap()
        .success()
}
fn create_branch(b: &str) -> bool {
    Command::new("git")
        .arg("branch")
        .arg(b)
        .current_dir(".")
        .spawn()
        .expect("git")
        .wait()
        .unwrap()
        .success()
}

fn remove_branch(b: &str) -> bool {
    Command::new("git")
        .arg("branch")
        .arg("-d")
        .arg(b)
        .current_dir(".")
        .spawn()
        .expect("git")
        .wait()
        .unwrap()
        .success()
}

fn add() -> bool {
    Command::new("git")
        .arg("add")
        .arg(".")
        .current_dir(".")
        .spawn()
        .expect("git")
        .wait()
        .unwrap()
        .success()
}

fn init() -> bool {
    create_branch(DEV_BRANCH) && checkout(DEV_BRANCH)
}

fn merge(branch: &str) -> bool {
    Command::new("git")
        .arg("merge")
        .arg(branch)
        .current_dir(".")
        .spawn()
        .expect("git")
        .wait()
        .unwrap()
        .success()
}
fn start_feature(name: &str) -> bool {
    Command::new("git")
        .arg("checkout")
        .arg("-b")
        .arg(format!("{FEATURE_BRANCH_PREFIX}/{name}").as_str())
        .arg(DEV_BRANCH)
        .current_dir(".")
        .spawn()
        .expect("git")
        .wait()
        .unwrap()
        .success()
}
fn finish_feature(name: &str) -> bool {
    assert!(checkout(DEV_BRANCH));
    assert!(pull(DEV_BRANCH));
    assert!(merge(format!("{FEATURE_BRANCH_PREFIX}/{name}").as_str()));
    assert!(remove_branch(
        format!("{FEATURE_BRANCH_PREFIX}/{name}").as_str()
    ));
    true
}

fn ask(msg: &str) -> String {
    let mut x: String;
    loop {
        x = Text::new(msg).prompt().unwrap().to_string();
        if x.is_empty() {
            continue;
        }
        break;
    }
    x
}

fn feature(name: &str, v: &Verb) -> bool {
    match v {
        Verb::Start => start_feature(name),
        Verb::Finish => finish_feature(name),
    }
}

fn pull(branch: &str) -> bool {
    Command::new("git")
        .arg("pull")
        .arg("origin")
        .arg(branch)
        .current_dir(".")
        .spawn()
        .expect("git")
        .wait()
        .unwrap()
        .success()
}
fn stash() -> bool {
    Command::new("git")
        .arg("stash")
        .current_dir(".")
        .spawn()
        .expect("git")
        .wait()
        .unwrap()
        .success()
}

fn install_program() -> bool {
    Command::new("cargo")
        .arg("install")
        .arg("--path")
        .arg(".")
        .current_dir(".")
        .spawn()
        .expect("cargo")
        .wait()
        .unwrap()
        .success()
}

fn run_program() -> bool {
    Command::new("cargo")
        .arg("run")
        .current_dir(".")
        .spawn()
        .expect("cargo")
        .wait()
        .unwrap()
        .success()
}

fn update() -> bool {
    Command::new("cargo")
        .arg("update")
        .current_dir(".")
        .spawn()
        .expect("cargo")
        .wait()
        .unwrap()
        .success()
}

fn stash_apply(path: &str, index: usize) {
    let mut repo: Repository = open(path);
    repo.stash_apply(index, None).expect("msg");
}
fn stash_drop(path: &str, index: usize) {
    let mut repo: Repository = open(path);
    repo.stash_drop(index).expect("Failed to drop a stash");
}

fn remove_dependencies() -> bool {
    let dependencies = MultiSelect::new("Select dependencies to remove : ", dependencies())
        .prompt()
        .unwrap();
    if dependencies.is_empty() {
        return remove_dependencies();
    }
    for d in &dependencies {
        assert!(Command::new("cargo")
            .arg("rm")
            .arg(d.as_str())
            .current_dir(".")
            .spawn()
            .expect("cargo")
            .wait()
            .unwrap()
            .success());
    }
    true
}

fn test_application() -> bool {
    Command::new("cargo")
        .arg("test")
        .arg("-j")
        .arg("4")
        .arg("--")
        .arg("--show-output")
        .current_dir(".")
        .spawn()
        .expect("cargo")
        .wait()
        .unwrap()
        .success()
}

fn publish() -> bool {
    Command::new("cargo")
        .arg("publish")
        .current_dir(".")
        .spawn()
        .expect("cargo")
        .wait()
        .unwrap()
        .success()
}

fn send(path: &str) {
    let repo: Repository = open(path);
    let mut remote_names: Vec<String> = Vec::new();

    // Iterate over all configured remotes
    for remote_name in repo.remotes().expect("No remote has been founded").iter() {
        let remote_name = remote_name.unwrap_or_default(); // Handle optional remote names
        remote_names.push(String::from(remote_name));
    }

    for remote_name in &remote_names {
        let mut remote = repo.find_remote(remote_name).expect("Failed to get remote");

        // Update remote refs to get latest changes
        remote
            .fetch(&["HEAD"], None, None)
            .expect("Failed to fetch");
        remote
            .push(&["refs/heads/*:refs/heads/*"], None)
            .expect("msg");
    }
}
fn show_status(path: &str) {
    let repo: Repository = open(path);
    let mut opts = StatusOptions::new();
    opts.include_ignored(false) // Exclude ignored files (optional)
        .include_untracked(true) // Include untracked files
        .recurse_untracked_dirs(true); // Recurse into untracked directories

    let statuses = repo
        .statuses(Some(&mut opts))
        .expect("Failed to get status");

    for entry in &statuses {
        let path = entry.path().unwrap_or("unknown");
        let status = entry.status();
        println!("{}: {:?}", path, status);
    }
}
fn options() -> Vec<String> {
    let mut options: Vec<String> = Vec::new();
    for option in OPTIONS {
        options.push(option.to_string());
    }
    options
}
impl Flow {
    pub fn menu() -> String {
        Select::new("Select an option below : ", options().to_vec())
            .prompt()
            .unwrap()
    }
}
fn flow(zuu: bool) -> ExitCode {
    if zuu.eq(&false) {
        return ExitCode::FAILURE;
    }
    match Flow::menu().as_str() {
        _ => {}
    }
    ExitCode::SUCCESS
}

fn tags(path: &str) -> Vec<String> {
    let repo = open(path);
    let mut tags: Vec<String> = Vec::new();

    // Get an iterator over all tags in the repository
    let tag_names = repo.tag_names(None).expect("NO tags");

    // Iterate and print each tag name
    for tag_name in &tag_names {
        let tag_name = tag_name.unwrap_or("<unnamed>");
        tags.push(tag_name.to_string());
    }
    tags
}

fn delete_tag() -> bool {
    let tag = ask("Enter the name of the tag to delete : ");
    Command::new("git")
        .arg("tag")
        .arg("-d")
        .arg(tag.as_str())
        .spawn()
        .expect("git")
        .wait()
        .unwrap()
        .success()
}

fn current_branch(path: &str) -> String {
    let mut name: String = String::new();
    let r: Repository = open(path);
    let head = r.head().expect("msg");
    if head.is_branch() {
        name = head.shorthand().unwrap_or("detached HEAD").to_string();
    }
    name
}
fn show_current_branches(path: &str) {
    println!("* {}", current_branch(path));
}

fn remove_branches(path: &str) {
    let branches: Vec<String> = MultiSelect::new("Select branches to delete : ", branches(path))
        .prompt()
        .unwrap();
    for branch in &branches {
        assert!(remove_branch(branch));
    }
}
fn branches(path: &str) -> Vec<String> {
    let repo: Repository = open(path);
    let mut branches: Vec<String> = Vec::new();
    let all_branches: Branches = repo.branches(Some(BranchType::Local)).expect("msg");
    for branch in all_branches {
        let (branch, _) = branch.expect("msg");
        let branch_name = branch
            .name()
            .expect("Failed to get branch name")
            .unwrap_or("<unnamed>");
        branches.push(branch_name.to_string());
    }
    branches
}

fn open(path: &str) -> Repository {
    Repository::open(path).expect("Not a git repository")
}

fn logs(path: &str) {
    let repo = open(path);
    let mut revwalk = repo.revwalk().expect("msg"); // Create a Revwalk object to iterate through commits
    revwalk.push_head().expect("msg"); // Start from the HEAD commit

    for oid in revwalk {
        let oid = oid.expect("Failed to get commit id"); // Get the commit ID
        let commit = repo.find_commit(oid).expect("Failed to get commit object"); // Find the commit object
        println!("Commit: {}", oid);
        println!("Commit: {}", oid);
        println!("Author: {}", commit.author());
        println!("Date: {}", commit.time().seconds());
        println!("Message:\n{}", commit.message().unwrap_or("No message"));
        println!("--------------------");
    }
}
fn main() -> ExitCode {
    flow(zuu())
}
